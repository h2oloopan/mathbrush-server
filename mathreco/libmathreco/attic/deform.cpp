#include "deform.h"
#include "group.h"
#include "stroke.h"
#include "stroke-alg.h"
#include "dist.h"
#include "interp.h"
#include "match.h"
#include "gauss.h"
#include "error.h"
#include "debug.h"
#include "memory.h"

#include <cmath>
#include <limits>


namespace scg
{


static double
iterate_match_stroke(NormalizedStroke &model, const NormalizedStroke &input, double variance, double &deform_cost)
{
	deform_cost = 0.0;
	
	double fit_cost = 0.0;
	double whitespace_cost = 0.0;

    double *P_input_generated = 0;    
    double **P_model_gen_input = 0;
    
    P_input_generated = DEBUG_NEW double[num_points(input)];
    if (!P_input_generated) {
        goto clean_up;
    }
    
    P_model_gen_input = DEBUG_NEW double *[num_points(model)];
    if (!P_model_gen_input) {
        goto clean_up;
    }
    std::fill(P_model_gen_input, P_model_gen_input + num_points(model), static_cast<double *>(0));
    for (unsigned i = 0; i < num_points(model); i++) {
        P_model_gen_input[i] = DEBUG_NEW double[num_points(input)];
        if (!P_model_gen_input[i]) {
            goto clean_up;
        }
    }
    
    
    
	// calculate the fit cost by finding the probability of each input point being generated by the model points,
	// given their gaussian distribution.
	// also calculate the probability of each model point generating each input point.
	for (unsigned i = 0; i < num_points(input); i++) {
		P_input_generated[i] = 0.0;
		for (unsigned j = 0; j < num_points(model); j++) {
			double P_gen = gauss_pdf(dist_sq(model.x[j], model.y[j], input.x[i], input.y[i]), variance);
			P_model_gen_input[j][i] = P_gen;
			P_input_generated[i] += P_gen;
		}
		P_input_generated[i] /= num_points(model);
		fit_cost += -std::log(P_input_generated[i]);
	}

    fit_cost = fit_cost / num_points(input);
    	
	// find the responsibility of each model point for generating each input point
	// and deform the model to the center-of-gravity of its influence on the input model.
	for (unsigned i = 0; i < num_points(model); i++) {
	    double total_resp = 0.0;
	    for (unsigned j = 0; j < num_points(input); j++) {
	        total_resp += P_model_gen_input[i][j] / (P_input_generated[j] * num_points(model));
	    }
	    total_resp /= num_points(input);

        whitespace_cost += -std::log(total_resp);

	    
		// move the model point and compute cost for the movement based
		// on the model point's gaussian distribution
		double tmpx = model.x[i];
		double tmpy = model.y[i];
		
        //debug_out << "    (model.x[" << i << "], model.x[" << i << "]) = (" << tmpx << ", " << tmpy << ")\n";
		
		for (unsigned int j = 0; j < num_points(input); j++) {
			double pixel_responsibility = P_model_gen_input[i][j] / (P_input_generated[j] * num_points(model));
			tmpx += pixel_responsibility * (input.x[j] - model.x[i]);
			tmpy += pixel_responsibility * (input.y[j] - model.y[i]);					
            //debug_out << "    (tmpx, tmpy) = (" << tmpx << ", " << tmpy << ")\n";
		}
        
		deform_cost += -std::log(gauss_pdf(dist_sq(model.x[i], model.y[i], tmpx, tmpy), variance));
        //debug_out << dist_sq(model.x[i], model.y[i], tmpx, tmpy) << "    " << variance << "   "  << deform_cost << std::endl;
        
		model.x[i] = tmpx;
		model.y[i] = tmpy;
	}
	
	deform_cost = deform_cost / num_points(model);
	whitespace_cost = whitespace_cost / num_points(model);

    //debug_out << "   fit_cost = " << fit_cost << std::endl;
    //debug_out << "   deform_cost = " << deform_cost << std::endl;
    //debug_out << "   whitespace_cost = " << whitespace_cost << std::endl;

clean_up:
    delete[] P_input_generated;
	if (P_model_gen_input) {
	    for (unsigned i = 0; i < num_points(model); i++) {
	        delete[] P_model_gen_input[i];
	    }
	    delete[] P_model_gen_input;
    }
    
	return fit_cost + deform_cost + whitespace_cost;
}


static double
match_stroke(const NormalizedStroke &real_model, const NormalizedStroke &real_input, double cent_dx, double cent_dy)
{	
    NormalizedStroke model = translate(real_model, cent_dx, cent_dy);
    NormalizedStroke input;
    
/*    if (stroke_is_dot(real_model) && stroke_is_dot(real_input)) {
        return 10.0;
    }
*/
    if (num_points(real_input) != num_points(model)) {
        input = subdivide(real_input, num_points(model));
    }
    else {
        input = copy(real_input);
    }
    
	double variance = 625.0;

	double stroke_cost = 0.0;
	double deform_cost = 0.0;
	
	double last_cost;
    double iteration_cost;
    
	// iterate through the match cost calculation and subdivision loop until there is (almost) no model deformation
	// or the loop runs 5 times, whichever happens first
	int it = 0;
	do {
		it++;

		last_cost = deform_cost;

		iteration_cost = iterate_match_stroke(model, input, variance, deform_cost);
		//debug_out << "  iteration_cost = " << iteration_cost << std::endl;
		stroke_cost += iteration_cost;

		variance *= 0.5;

		model = subdivide(model, num_points(model) * 2);
		input = subdivide(input, num_points(input) * 2);
	} while (std::abs(deform_cost - last_cost) > 1.0 && it < 5);

	//stroke_cost /= it;
	//stroke_cost = iteration_cost;

	return stroke_cost;
}


int
deformation_match(const NormalizedStrokeGroup &model, const NormalizedStrokeGroup &input, Match &match)
{
    if (num_strokes(input) < num_strokes(model)) {
        match.num_strokes = 0;
        return 0;
    }

	double cent_dx = x_center(input) - x_center(model);
	double cent_dy = y_center(input) - y_center(model);
	
	double total_cost = 0.0;

	for (NormalizedStrokeGroup::const_iterator mod_stroke = model.begin(), in_stroke = input.begin();
	     mod_stroke != model.end(); ++mod_stroke, ++in_stroke)
	{
		double stroke_cost = match_stroke(*mod_stroke, *in_stroke, cent_dx, cent_dy);
		total_cost += stroke_cost;
	}

	//double threshold = 100.0;
	total_cost /= num_strokes(input);

	//if (total_cost < threshold) {
		match.raw_score = total_cost;
		match.num_strokes = num_strokes(model);
		//match.confidence = std::max(0.0, 1.0 - (match.raw_score / threshold));
	//}

    return 0;
}


}

