#ifndef TREEWALK_H_
#define TREEWALK_H_

#include <map>
#include <set>
#include <vector>

#include "MathRecoTypes.h"
#include "grammar.h"
#include "parser-fwd.h"
#include "expr-node.h"


/*

Iteration consists of extracting valid parse trees from the parse graph generated by
code in parser.cc.  Here 'valid' means that the root node has a specific semantic type
and the tree contains only some particular given terminal nodes.

The implementation is top-down where links in the parse graph are checked before
descent to ensure they give appropriate terminal nodes. (This can be determined by
examining the parse cell's source span and split point due to parse coherence
requirements.)

Iterators are stored in a shared cache so that they may be re-used.  There is a 1:1
correspondence between (parse node, valid terminal mask) pairs and tree_iterator
objects.

Each iterator keeps a list of the k best parse trees rooted at the corresponding
parse node; this list grows as more trees are requested by the user. It also keeps
a heap (sorted by score) of known, but not necessarily next-best, parse trees.

When the next tree is requested, the iterator gets the next-best tree from the
current-best parse link, adds it to the heap, then pops out the next-best tree
overall.

*/



namespace scg
{




// cell_key represents the (parse node, valid terminal mask) pair mentioned above
struct cell_key {
	CellRef root;
	terminal_mask_t terminals;

	cell_key() { }
	explicit cell_key(const CellRef &root_) : root(root_) { }
	cell_key(const CellRef &root_, const terminal_mask_t &terminals_) : root(root_), terminals(terminals_) { }

	inline bool operator==(const cell_key &rhs) const
		{ return root == rhs.root && terminals == rhs.terminals; }

	inline bool operator<(const cell_key &rhs) const
		{ return root < rhs.root || (root == rhs.root && terminals < rhs.terminals); }
	
	const static cell_key NIL; // ie. invalid key
};

std::ostream &operator<<(std::ostream &os, const cell_key &key);



class tree_iterator;


typedef std::map<cell_key, tree_iterator *> iter_cache_t;

// data shared between all iterators for a particular parse context:
// iterator cache and flags
struct iterator_shared_data {
	iter_cache_t cache;
	bool prevent_terminal_alternates;
	bool prevent_subtree_alternates;
};


template <typename T, typename P>
class deref_pred
{
	P p;
public:
	inline bool operator()(const T *lhs, const T *rhs) const { return p(*lhs, *rhs); }
};


// iteration_link stores attributes of a particular parse link from a parent node:
// iterators for child nodes along with current tree rankings, current score,
// box relation score (which stays constant regardless of tree rankings since the
// terminals involved do not change), and generating production
struct iteration_link {
	double score;
	tree_iterator *left;
	unsigned lefti;
	tree_iterator *right;
	unsigned righti;

	const CNFProduction *P;

	relation_class_t rclass;
	double rel_score;

	iteration_link() : left(0), right(0), score(0.0), rel_score(0.0), P(0) { }
	iteration_link(double score_, tree_iterator *left_, unsigned lefti_, tree_iterator *right_, unsigned righti_, relation_class_t rclass_, double rel_score_, const CNFProduction *P_)
		: score(score_), left(left_), lefti(lefti_), right(right_), righti(righti_), rclass(rclass_), rel_score(rel_score_), P(P_) { }

	inline bool operator<(const iteration_link &rhs) const { return score < rhs.score; }
	inline bool operator>(const iteration_link &rhs) const { return score > rhs.score; }

	inline bool operator==(const iteration_link &rhs) const
		{ return left == rhs.left && lefti == rhs.lefti && right == rhs.right && righti == rhs.righti; }

	inline bool operator!=(const iteration_link &rhs) const
		{ return !(*this == rhs); }
};


/*

tree_iterator contains the core iteration algorithms build() and tree().
Anything else is a helper method.
The only tricky bit is next_indices.  At a given nonterminal parse node,
the 0'th tree must use child trees (0,0).  But the 1'th tree can use (0,1)
or (1,0), and so on.  The next indices to use for tree k are not determined
solely by those used for tree k-1.  So we maintain a cache of the valid
tree index options for each pair of children reachable from a node and try
each combination of trees.

*/

class tree_iterator
{
public:
	// a next_indices_t instance R stores the valid index pairs for calling tree() on child nodes.
	// The index pairs are given by (R[k],k)
	typedef std::vector<unsigned> next_indices_t;
	typedef std::map<std::pair<cell_key, cell_key>, next_indices_t> next_index_cache_t;


public:
	tree_iterator(iterator_shared_data &shared_, const ParseContext *ctx_, const terminal_mask_t &terminals_);
	~tree_iterator();

	void build(const CellRef &root);

	expression_node *tree(unsigned rank);

	const cell_key &key() const { return self_key; }

private:
	void build_(const CellRef &root, unsigned nbranches);

	expression_node *tree_(unsigned rank, bool building);

	expression_node *build_expression(const iteration_link &score, bool building);

	tree_iterator *build_subiter(const CellRef &child, const std::vector<bool> &terminals, unsigned nbranches);
	expression_node *top_tree_internal() const;

	void extract_source_terminals(const CellSource &src, std::vector<bool> &terminals);
	void extract_source_left_terminals(const CellSource &src, std::vector<bool> &terminals);
	void extract_source_right_terminals(const CellSource &src, std::vector<bool> &terminals);

	next_indices_t &get_next_indices(const tree_iterator *left, const tree_iterator *right);
	bool next_indices_exist(const tree_iterator *left, const tree_iterator *right);
	void increment_next_indices(const iteration_link &score);

private:
	iterator_shared_data &shared;

	const ParseContext *ctx;
	const ParseCell *cell;
	expression_box bounds;

	cell_key self_key;

	typedef std::set<iteration_link, std::greater<iteration_link> > score_heap_t;
	score_heap_t local_scores;

	std::vector<expression_node *> ranked_trees;

	next_index_cache_t next_indices;

	bool is_terminal;
	bool is_distinct_subtree;

	unsigned last_clean;
};



class expression_iterator : public ExpressionIterator
{
public:
	expression_iterator(const ParseContext *ctx_, const std::set<CNFGrammar::gid_t> gids_, const unsigned *strokes_, unsigned nstrokes_, int flags_);
	~expression_iterator();

	const ExpressionTree *next();

	void release() { delete this; }

	void SetFlags(unsigned flags_)
	{
		flags = flags_;
		shared.prevent_terminal_alternates = ((flags_ & ExpressionIterator::Flags::AllowTerminalAlternates) == 0);
		shared.prevent_subtree_alternates = ((flags_ & ExpressionIterator::Flags::AllowSubtreeAlternates) == 0);
	}

	unsigned GetFlags() const { return flags; }


private:
	unsigned flags;
	std::vector<std::pair<tree_iterator *, unsigned> > iterators;
	const expression_node *best_tree;

	iterator_shared_data shared;
};



}


#endif
